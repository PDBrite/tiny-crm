{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/jdog/projects/lead-manager/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js'\nimport { Database } from '@/types/database'\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n\nexport const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)\n\n// Client-side Supabase client\nexport function createClientComponentClient() {\n  return createClient<Database>(supabaseUrl, supabaseAnonKey)\n} "],"names":[],"mappings":";;;;AAAA;;AAGA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,CAAA,GAAA,yLAAA,CAAA,eAAY,AAAD,EAAY,aAAa;AAGrD,SAAS;IACd,OAAO,CAAA,GAAA,yLAAA,CAAA,eAAY,AAAD,EAAY,aAAa;AAC7C","debugId":null}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"sources":["file:///Users/jdog/projects/lead-manager/src/app/api/daily-touchpoints/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { supabase } from '../../../lib/supabase'\nimport { getTouchpointsDueToday, getOverdueTouchpoints } from '../../../utils/outreach-scheduler'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const url = new URL(request.url)\n    const type = url.searchParams.get('type') // 'today', 'overdue', or 'all'\n    const date = url.searchParams.get('date') // Specific date in YYYY-MM-DD format\n    const campaignId = url.searchParams.get('campaignId') // Filter by campaign\n    const company = url.searchParams.get('company') // Filter by company\n    \n    // If specific date is provided, use that; otherwise use today\n    let targetDate: Date\n    if (date) {\n      targetDate = new Date(date + 'T00:00:00.000Z')\n    } else {\n      targetDate = new Date()\n      targetDate.setHours(0, 0, 0, 0)\n    }\n    \n    const nextDay = new Date(targetDate)\n    nextDay.setDate(nextDay.getDate() + 1)\n\n    let touchpoints = []\n    \n    if (company === 'Avalern') {\n      // For Avalern, fetch touchpoints for district contacts\n      let query = supabase\n        .from('touchpoints')\n        .select(`\n          *,\n          district_contact:district_contacts!inner(\n            id,\n            first_name,\n            last_name,\n            email,\n            phone,\n            title,\n            district_lead:district_leads!inner(\n              id,\n              district_name,\n              county,\n              company,\n              campaign_id,\n              campaign:campaigns(id, name, company)\n            )\n          )\n        `)\n        .is('completed_at', null) // Only get uncompleted touchpoints\n        .eq('district_contact.district_lead.company', 'Avalern')\n\n      // Filter by campaign if specified\n      if (campaignId) {\n        query = query.eq('district_contact.district_lead.campaign_id', campaignId)\n      }\n\n      // If specific date is provided, get touchpoints for that date\n      if (date) {\n        query = query\n          .gte('scheduled_at', targetDate.toISOString())\n          .lt('scheduled_at', nextDay.toISOString())\n      } else {\n        // Filter by type for legacy support\n        if (type === 'today') {\n          query = query\n            .gte('scheduled_at', targetDate.toISOString())\n            .lt('scheduled_at', nextDay.toISOString())\n        } else if (type === 'overdue') {\n          query = query.lt('scheduled_at', targetDate.toISOString())\n        } else {\n          // Get both today and overdue\n          query = query.lt('scheduled_at', nextDay.toISOString())\n        }\n      }\n\n      const { data: districtTouchpoints, error } = await query\n        .order('scheduled_at', { ascending: true })\n\n      if (error) {\n        console.error('Error fetching district touchpoints:', error)\n        return NextResponse.json(\n          { error: 'Failed to fetch touchpoints' },\n          { status: 500 }\n        )\n      }\n\n      // Transform district touchpoints to match the expected format\n      touchpoints = (districtTouchpoints || []).map(tp => ({\n        ...tp,\n        lead: {\n          id: tp.district_contact.id,\n          first_name: tp.district_contact.first_name,\n          last_name: tp.district_contact.last_name,\n          email: tp.district_contact.email,\n          phone: tp.district_contact.phone,\n          city: tp.district_contact.district_lead.county,\n          company: tp.district_contact.district_lead.district_name,\n          campaign_id: tp.district_contact.district_lead.campaign_id,\n          campaign: tp.district_contact.district_lead.campaign\n        }\n      }))\n    } else {\n      // For other companies (like CraftyCode), fetch regular lead touchpoints\n      let query = supabase\n        .from('touchpoints')\n        .select(`\n          *,\n          lead:leads!inner(\n            id,\n            first_name,\n            last_name,\n            email,\n            phone,\n            city,\n            company,\n            campaign_id,\n            campaign:campaigns(name, company)\n          )\n        `)\n        .is('completed_at', null) // Only get uncompleted touchpoints\n\n      // Filter by company if specified\n      if (company) {\n        query = query.eq('lead.campaign.company', company)\n      }\n\n      // Filter by campaign if specified\n      if (campaignId) {\n        query = query.eq('lead.campaign_id', campaignId)\n      }\n\n      // If specific date is provided, get touchpoints for that date\n      if (date) {\n        query = query\n          .gte('scheduled_at', targetDate.toISOString())\n          .lt('scheduled_at', nextDay.toISOString())\n      } else {\n        // Filter by type for legacy support\n        if (type === 'today') {\n          query = query\n            .gte('scheduled_at', targetDate.toISOString())\n            .lt('scheduled_at', nextDay.toISOString())\n        } else if (type === 'overdue') {\n          query = query.lt('scheduled_at', targetDate.toISOString())\n        } else {\n          // Get both today and overdue\n          query = query.lt('scheduled_at', nextDay.toISOString())\n        }\n      }\n\n      const { data: leadTouchpoints, error } = await query\n        .order('scheduled_at', { ascending: true })\n\n      if (error) {\n        console.error('Error fetching lead touchpoints:', error)\n        return NextResponse.json(\n          { error: 'Failed to fetch touchpoints' },\n          { status: 500 }\n        )\n      }\n\n      touchpoints = leadTouchpoints || []\n    }\n\n    // If specific date is provided, return touchpoints for that date\n    if (date) {\n      return NextResponse.json({\n        touchpoints: touchpoints,\n        date: date,\n        total: touchpoints.length\n      })\n    }\n\n    // Legacy categorization for today/overdue\n    const todayTouchpoints = []\n    const overdueTouchpoints = []\n\n    for (const touchpoint of touchpoints) {\n      const scheduledDate = new Date(touchpoint.scheduled_at)\n      scheduledDate.setHours(0, 0, 0, 0)\n\n      if (scheduledDate < targetDate) {\n        overdueTouchpoints.push(touchpoint)\n      } else if (scheduledDate.getTime() === targetDate.getTime()) {\n        todayTouchpoints.push(touchpoint)\n      }\n    }\n\n    // Group by type for easier processing\n    const groupedToday = groupTouchpointsByType(todayTouchpoints)\n    const groupedOverdue = groupTouchpointsByType(overdueTouchpoints)\n\n    return NextResponse.json({\n      today: {\n        total: todayTouchpoints.length,\n        by_type: groupedToday,\n        touchpoints: todayTouchpoints\n      },\n      overdue: {\n        total: overdueTouchpoints.length,\n        by_type: groupedOverdue,\n        touchpoints: overdueTouchpoints\n      },\n      summary: {\n        total_due: todayTouchpoints.length + overdueTouchpoints.length,\n        emails_due: (groupedToday.email || 0) + (groupedOverdue.email || 0),\n        calls_due: (groupedToday.call || 0) + (groupedOverdue.call || 0),\n        linkedin_due: (groupedToday.linkedin_message || 0) + (groupedOverdue.linkedin_message || 0)\n      }\n    })\n\n  } catch (error) {\n    console.error('Error fetching daily touchpoints:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n// POST endpoint to mark touchpoints as completed\nexport async function POST(request: NextRequest) {\n  try {\n    const { touchpointId, outcome, outcomeEnum, notes } = await request.json()\n    \n    if (!touchpointId) {\n      return NextResponse.json(\n        { error: 'Touchpoint ID is required' },\n        { status: 400 }\n      )\n    }\n\n    const { data: touchpoint, error } = await supabase\n      .from('touchpoints')\n      .update({\n        completed_at: new Date().toISOString(),\n        outcome: outcome || null,\n        outcome_enum: outcomeEnum || null,\n        content: notes ? `${notes}` : undefined\n      })\n      .eq('id', touchpointId)\n      .select(`\n        *,\n        lead:leads(id, email, first_name, last_name),\n        district_contact:district_contacts(\n          id, \n          email, \n          first_name, \n          last_name,\n          district_lead:district_leads(id)\n        )\n      `)\n      .single()\n\n    if (error) {\n      return NextResponse.json(\n        { error: 'Failed to update touchpoint' },\n        { status: 500 }\n      )\n    }\n\n    // Update appropriate record's last_contacted_at\n    if (touchpoint.lead) {\n      await supabase\n        .from('leads')\n        .update({ last_contacted_at: new Date().toISOString() })\n        .eq('id', touchpoint.lead.id)\n    } else if (touchpoint.district_contact) {\n      await supabase\n        .from('district_leads')\n        .update({ last_contacted_at: new Date().toISOString() })\n        .eq('id', touchpoint.district_contact.district_lead.id)\n    }\n\n    return NextResponse.json({\n      success: true,\n      touchpoint,\n      message: 'Touchpoint marked as completed'\n    })\n\n  } catch (error) {\n    console.error('Error completing touchpoint:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\nfunction groupTouchpointsByType(touchpoints: any[]) {\n  return touchpoints.reduce((acc, touchpoint) => {\n    const type = touchpoint.type\n    acc[type] = (acc[type] || 0) + 1\n    return acc\n  }, {})\n} "],"names":[],"mappings":"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","debugId":null}}]
}